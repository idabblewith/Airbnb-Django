1. Setup
    Create folder && cd in
    Create venv
    Activate venv
    Install poetry
    Poetry init
    poetry add django
    poetry shell (optionally)
    django-admin

    django-admin startproject config .

-------------------------------------------------------------------------

2-3. OOP & Django Basics
    py manage.py runserver
        sb.sqlite3 created
        nav to http://127.0.0.1:8000//admin
        close 
    py manage.py migrate && py manage.py runserver
    py manage.py createsuperuser
    config > settings.py > change timezone and language of server 

-------------------------------------------------------------------------

4. Django Apps
    py manage.py startapp houses
    houses > models > Create house models
    config > settings > 
        installed_apps = system_apps + custom_apps
        add houses app to custom apps ("houses.apps.HousesConfig")
    houses > admin > 
        from .models import House
        @admin.register(House)
        class HouseAdmin(admin.ModelAdmin):
            pass
    killserver & py manage.py makemigrations & migrate & runserver
    Add House > Save > Change __str__ of model so it no longer shows "object"
        models >
            def __str__(self):
                return self.name
    admin >
        list_display = ["name", "price_per_night", "pets_allowed",]
        list_filter = ["price_per_night", "pets_allowed",]
        search_fields = ["address__startswith",]
        
-------------------------------------------------------------------------

5. Users App
    py manage.py startapp users
    config > settings > "users.apps.UsersConfig" add 
    models > 
        from django.contrib.auth.models import AbstractUser

        class User(AbstractUser):
            pass
    config > settings > AUTH_USER_MODEL = "users.User"
    Gut db and migrations files
    py manage.py makemigrations
    py manage.py migrate
    py manage.py createsuperuser
    admin >
        from django.contrib.auth.admin import UserAdmin
        from .models import UserModel

        @admin.register(UserModel)
        class CustomUserAdmin(UserAdmin):
            pass
    overwrite AbstractUser first and last names to be non-editable
        first_name = models.CharField(
            max_length=150,
            editable=False,
        )
        last_name = models.CharField(
            max_length=150,
            editable=False,
        )
    do user model custom fields
        defaults for is_host and name so existing users dont get error
    add fieldsets/ fields to admin
        fieldsets = (
            ("Profile",
                {
                   "fields":("username","password","name","email","is_host"), 
                },
            ),
            ("Permissions",
                {
                    "fields": (
                        "is_active",
                        "is_staff",
                        "is_superuser",
                        "groups",
                        "user_permissions"
                    ),
                    "classes": ("collapse",),
                },
            ),
            ("Important Dates",
                {
                    "fields":("last_login","date_joined"),
                    "classes": ("collapse",),
                },
            ),
        )
        fields = ["email","password","name"]
    visit http://127.0.0.1:8000/admin/users/user/1/change/
    do list_display
    add foreign key of user to house as owner
        owner = models.ForeignKey(
            "users.User",
            on_delete=models.CASCADE, (SetNULL for payments - records u need to keep)
        )
    killserver gut db and migrations
    uninstall houses from settings
    delete houses app
    makemigrations migrate createsuperuser runserver
     
-------------------------------------------------------------------------

6. Models & Admin

    poetry add Pillow

    0. USER
    users.models > 
        class GenderChoices(models.TextChoices):
            MALE = ("male", "Male")
            FEMALE = ("female", "Female") 
        class LanguageChoices(models.TextChoices):
            EN = "en", "English"
            JP = "jp", "Japanese"
        class CurrencyChoices(models.TextChoices):
            AUD = "aud", "Australian Dollar"
            JPY = "jpy", "Japanese Yen"
        profile_photo = models.ImageField(blank=True)
        gender = models.CharField(max_length=10, choices=GenderChoices.choices,)
        language = models.CharField(max_length=2, choices=LangaugeChoices.choices,)
        currency = models.CharField(max_length=3, choices=CurrencyChoices.choices,)

    py manage.py makemigrations && py manage.py migrate
    py manage.py createsuperuser
    py manage.py runserver
    users.admin >
        add to profile fieldset fields
            "profile_photo",
            "gender",
            "language",
            "currency",

    1. ROOM
    py manage.py startapp rooms
    config > settings.py > "rooms.apps.RoomsConfig", <-- Customapp
    rooms > models > Define Room model

    2. MANY TO MANY
    startapp common
    settings -> "common.apps.CommonConfig",
    Define abstract model CommonModel
        class CommonModel(models.Model):
            created_at = models.DateTimeField(auto_now_add=True)
            updated_at = models.DateTimeField(auto_now=True)

            class Meta:
                abstract = True
                
    Define Amenity - 
    py manage.py makemigrations
    py manage.py migrate

    3. room > admin > Room, Amenity Admin

    4. Rooms Admin
        list_display, list_filter, readonly_fields,

    5. Experiences
        py manage.py startapp experiences
        install in settings
        define experience and perk
        py manage.py makemigrations && py manage.py migrate
        admin > Experience & Perk Admin
        Add str method to models
    
    6. Categories
        py manage.py startapp categories
        install in settings
        define categories model - name & kind
        add class Meta verbose_name_plural and str methods
        add category field to experiences & rooms models set_null on delete, nullable and blankable
        admin > CategoryAdmin

    7. Reviews 
        py manage.py startapp reviews
        install in settings
        define reviews model - user, room, experience, payload, rating
        py manage.py makemigrations && migrate
        admin > ReviewAdmin

    8. Wishlists
        py manage.py startapp wishlists
        install in settings 
        define model - 
        py manage.py makemigrations && py manage.py migrate
        admin > WishlistAdmin

    9. Bookings
        py manage.py startapp bookings
        install in settings
        define models -
        py manage.py makemigrations && py manage.py migrate
        admin

    10. Medias
        py manage.py startapp medias
        install in settings 
        define models - photo, video (use onetoone for video experience)
        py manage.py makemigrations && py manage.py migrate
        admin

    11. Direct Messages
        py manage.py startapp direct_messages
        install in settings
        define models - Room, Message
        py manage.py makemigrations && py manage.py migrate
        admin
        dm apps > dmconfig > verbose_name = "Direct Messages"



-------------------------------------------------------------------------

7. ORM

    1. Intro
        py manage.py shell (python interactive console with apps installed)

        READ
        a = Room.objects.get(name="")
        print(a.pk) 
        print(a.owner.email) etc

        UPDATE
        a.price = 20
        a.save()

    2. filter, get, create, delete
        Room.objects.all()
        Room.objects.get(var=value) get a single record
        Room.objects.filter(pets_allowed=True)
        Room.objects.filter(price__gt=15) 
            search greater or  less than or gt or equals/lt or equals gte lte
            or name__startswith="Apt"

        data = {
            name = "Amenity from console",

        }
        am = Amenity.objects.create(data)

        to_delete = Amenity.objects.get(pk=7)
        to_delete.delete()

    3. QuerySets
        Room.objects.filter(pets_allowed=True).exclude(price__lte=15).filter(name__contains="poo")
        or
        Room.objects.filter(pets_allowed=True, name__contains="poo", price__gt=15)
        .count()
        .all()[:5]

    4. Admin methods
        __exact __iexact="beatles blog"
        __contains="bob" icontains
        __startswith __istartswith
        __endswith __iendswith
        __range
        __date
        __year __month time, hour
        .exists()

        add "total_amenities" to admin for room &
            add to model def
                def total_amenities(self):
                    return self.amenities.count()
            or
            add to admin panel
                def total_amenities(self, room):
                    return room.amenities.count()

    5. ForeignKey Filter & Reverse Accessors

        Room.objects.filter(owner__username='tg')
            owner__username__startswith etc.
        or
        (recommended out of two)
        me = User.objects.get(pk=1)
        me.room_set.all()
        
    6. Related Name related_name

        Customise the name of reverse accessors

        simply add 'related_name="[NAME OF MODEL]"' to each model with a foreign key
        for room:
            owner = models.ForeignKey(
                "users.User",
                on_delete=models.CASCADE,
                related_name="rooms',
            )
        
        now you can call the rooms for each user from the user model:
            user.rooms.all()

        change rooms, wishlists, reviews, medias, bookings, direct_messages, experiences models to add related_name
            & migrate

        SAME AS backref in flask

    
-------------------------------------------------------------------------

8. POWER ADMIN

    1. Methods
        rooms > models > 
            def rating(self):
                count = self.reviews.count()
                if count == 0:
                    return "No reviews"
                else:
                    total_rating = 0
                    for review in self.reviews.all().values("rating"):   <---------OPTOMISATION RETURN ONLY CERTAIN VALUES with .values("var")
                        total_rating += review["rating"]
                    return round(total_rating / count, 2)

        rooms > admin >
            "reviews" in list_display
        
    2. Search fields
        rooms > admin >
            search_fields = [
                "^name",
                "=price",
                "owner__username",
            ]

        ^ = startswith
        = = exact
        __var = search on foreignkey


    3. Admin actions
        rooms > admin >
         at top:
            @admin.action(description="Set all prices to zero")
            def reset_prices(model_admin, request, queryset):
                for room in rooms.all():
                    room.price = 0
                    room.save()

            
         add to roomadmin:
            actions = [
                reset_prices,
            ]


    4. Custom Filters
        Ordering of filters matters

        reviews > admin >
            class WordFilter(admin.SimpleListFilter):
                title = "Filter by Words"
                parameter_name = "potato"

                def lookups(self, request, model_admin):
                    return [
                        ("good", "Good"),
                        ("great", "Great"),
                        ("awesome", "Awesome")
                    ]

                def queryset(self, request, queryset):
                    return queryset
                    # replace queryset with reviews in this case

            list_filter = [
                WordFilter,
                "rating",
                "user__is_host",
                "room__category",
                "room__pets_allowed",
            ]

-------------------------------------------------------------------------

9. URLS & VIEWS

    1. Views

        rooms > views >
            from django.http import HttpResponse

            def say_hello(req):
                return HttpResponse("hello")
        config > urls >
            from rooms import views as room_views

            urlpatterns = [
                path("rooms", room_views.say_hello)
            ]

    2. Include 

        create urls.py for each app and import them in the config

        config urls >
            from django.contrib import admin
            from django.urls import path, include


            urlpatterns = [
                path("admin/", admin.site.urls),
                path("rooms/", include("rooms.urls")),
            ]

        rooms urls >

            from . import views
            from django.urls import path

            urlpatterns = [
                path("", views.say_hello),
            ]


    3. URL Arguments

        rooms > views > 
            from django.shortcuts import render
            from django.http import HttpResponse


            def see_one_room(req, room_id):
                return HttpResponse(f"{room_id}")


            def see_all_rooms(req):
                return HttpResponse("All rooms")

        rooms > urls >
            from . import views
            from django.urls import path

            urlpatterns = [
                path("", views.see_all_rooms),
                path("<int:room_id>", views.see_one_room),
            ]


    4. render
        NOT RECOMMENDED (FLASK/JINJA STYLE) - WILL USE REACT
        in views 
            return render(req, "all_rooms.html", {
                "rooms": all_rooms
            })
    
        create rooms > templates/all_rooms.html

    5. Django Templates
        in html Templates >
            {{var}}

        {% for room in rooms %}
            <li>{{room.name}}
                <a href="/rooms/{{room.pk}}>
                    <br />
                    {% for amenity in rooms.amenities %}
                        <span>{{amenity.name}}</span>
                    {% endfor %}
                />
            </li>
        {% endfor %}

    6. DoesNotExist

        rooms > views >
            try:
                room = Room.objects.get(pk=room_id)
                return HttpResponse(f"{room}")
            except Room.DoesNotExist:
                return render(req, "404.html")

    7. Django v. React

        NO MORE TEMPLATES :D
        React for frontend

-------------------------------------------------------------------------

10. DJANGO REST FRAMEWORK

    poetry add djangorestframework

    settings.py >
        add 
            THIRD_PARTY_APPS = [
                "rest_framework"
            ]
        add to installed apps

    1. JSONResponse (NOT RECOMMENDED)

        NONONONONO

        categories > create urls.py >
            from . import views
            from django.urls import path

            urlpatterns = [
                path("", views.categories),
            ]

        config/urls.py >
            path("categories/", include("categories.urls")),


        NONONONONO

    2. api_view

        NONONONONO

        views >
            from django.core import serializers

            def categories(req):
                all = Category.objects.all()

                return JsonResponse(
                    {
                        "ok": True,
                        "categories": serializers.serialize("json", all),
                    }

        NONONONONO

    3. Serializer

        YESYESYESYESYES SORTA REPETITIVE

        categories > create serializers.py
            from rest_framework import serializers

            class CategorySerializer(serializers.Serializer):
                name = serializers.CharField(required=True)
                kind = serializers.CharField()

        views >
            @api_view()
            def categories(req):
                all = Category.objects.all()
                serializer = CategorySerializer(
                    all,
                    many=True,
                )

                return Response(
                    {
                        "ok": True,
                        "categories": serializer.data,
                    }
                )

        @api_view(["GET", "POST"])

    4. POST requests

        urls > 
            path("<int:pk>", views.category)

        views >

            def categories(req):
                if req.method == "GET":
                    all = Category.objects.all()
                    serializer = CategorySerializer(
                        all,
                        many=True,
                    )
                    return Response(serializer.data)
                elif req.method == "POST":
                    Category.objects.create(
                        name ---
                        kind -- req.data['']
                    )
                    return Response({"created":True})

            @api_view()
            def category(req, pk):
                cat = Category.objects.get(pk=pk)
                serializer = CategorySerializer(cat)

                return Response(serializer.data)


    5. is_valid()

        serializer.is_valid()
        serializer.errors
        IntegerField(read_only=True)

    6. save()

        if is_valid():
            a = serializer.save()
            return Response(
                a,
                status=200
            )
        else:
            return Response(
                serializer.errors,
                status=400
            )

        Category.objects.create(**validated_data)

    7. update()

        from rest_framework.exceptions import NotFound

        try:
            cat = Category.objects.get(pk=pk)
        except DoesNotExist:
            raise NotFound

        if req.mth == get:
            ser = ...
            return ...
        elif reqmeth ==put:
            ser = catser(
                cat,
                data=ser.data,
                partial=True,
            )
            if ser,isvalid()
                updated = ser.save()
                return res(catserializer(updated), status=200)
            else
                return res(ser.err)


    8. DELETE
        if req.meth == del
        cat.delete()
        return res(status=nocontent204)


    --------

    UPDATE URLS
    config > urls >
        path("api/v1/categories/", include("categories.urls")),

    --------

    9. APIView

        DELETE THE ABOVE

        urls >
            urlpatterns = [
                path("", views.Categories.as_view()),
                path("<int:pk>", views.CategoryDetail.as_view()),
            ]


        views >
            from .models import Category
            from .serializers import CategorySerializer
            from rest_framework.views import APIView
            from rest_framework.response import Response
            from rest_framework.exceptions import NotFound
            from rest_framework.status import (
                HTTP_200_OK,
                HTTP_201_CREATED,
                HTTP_202_ACCEPTED,
                HTTP_204_NO_CONTENT,
                HTTP_400_BAD_REQUEST,
            )


            class Categories(APIView):
                def get(self, req):
                    all_cat = Category.objects.all()
                    serializer = CategorySerializer(
                        all_cat,
                        many=True,
                    )
                    return Response(
                        serializer.data,
                        status=HTTP_200_OK,
                    )

                def post(self, req):
                    serializer = CategorySerializer(data=req.data)
                    if serializer.is_valid():
                        new_cat = serializer.save()
                        return Response(
                            CategorySerializer(new_cat).data,
                            status=201,
                        )
                    else:
                        return Response(serializer.errors)


            class CategoryDetail(APIView):
                def get_obj(self, pk):
                    try:
                        record = Category.objects.get(pk=pk)
                    except Category.DoesNotExist:
                        raise NotFound
                    return record

                def get(self, req, pk):
                    ser = CategorySerializer(self.get_obj(pk))
                    return Response(
                        ser.data,
                        status=HTTP_200_OK,
                    )

                def delete(self, req, pk):
                    cat = self.get_obj(pk)
                    cat.delete()
                    return Response(status=HTTP_204_NO_CONTENT)

                def put(self, req, pk):
                    ser = CategorySerializer(
                        self.get_obj(pk=pk),
                        req.data,
                        partial=True,
                    )
                    if ser.is_valid():
                        updated = ser.save()
                        return Response(
                            CategorySerializer(updated).data,
                            status=HTTP_202_ACCEPTED,
                        )
                    else:
                        return Response(
                            ser.errors,
                            status=HTTP_400_BAD_REQUEST,
                        )


    10. ModelSerializer

        RECOMMENDED

        from rest_framework import serializers
        from .models import Category

        class CategorySerializer(serializers.ModelSerializer):
            class Meta:
                model = Category
                exclude = ['id','created_at']            
                    OR fields = [a, b, c, d]

    11. ModelViewSet

        NOT RECOMMENDED

        views >
        from rf.viewsets import ModelViewSet

        class CategoryViewSet(ModelViewSet):
            serializer_class = CategorySerializer
            queryset = Category.objects.all()

        urls >
        urlpatterns = [
            path("", views.CategoryViewSet.as_view({
                'get':'list','post':'create',
            })),
            path("<int:pk>", views.CategoryViewSet.as_view({
                'get':'retrieve','put':'partial_updated','delete':'destroy',
            })),
        ]

    12. Conclusion

        Use APIView and ModelSerializer

-------------------------------------------------------------------------

11. REST API

    1. All Amenities & AmenityDetail

        conf > urls >
            urlpatterns = [
                path("admin/", admin.site.urls),
                path("graphql", GraphQLView.as_view(schema=schema)),
                path("api/v1/rooms/", include("rooms.urls")),
                path("api/v1/categories/", include("categories.urls")),
            ]


        rooms/views > 
            from .models import Amenity
            from .serializers import AmenitySerializer
            from rest_framework.exceptions import NotFound
            from rest_framework.views import APIView
            from rest_framework.response import Response
            from rest_framework.status import (
                HTTP_200_OK,
                HTTP_201_CREATED,
                HTTP_202_ACCEPTED,
                HTTP_204_NO_CONTENT,
                HTTP_400_BAD_REQUEST,
            )


            class Amenities(APIView):
                def get(self, req):
                    all = Amenity.objects.all()
                    ser = AmenitySerializer(all, many=True)
                    return Response(
                        ser.data,
                        status=HTTP_200_OK,
                    )

                def post(self, req):
                    ser = AmenitySerializer(data=req.data)
                    if ser.is_valid():
                        a = ser.save()
                        return Response(
                            AmenitySerializer(a).data,
                            status=HTTP_201_CREATED,
                        )


            class AmenityDetail(APIView):
                def go(self, pk):
                    try:
                        return Amenity.objects.get(pk=pk)
                    except Amenity.DoesNotExist:
                        raise NotFound

                def get(self, req, pk):
                    a = self.go(pk)
                    ser = AmenitySerializer(a)
                    return Response(
                        ser.data,
                        status=HTTP_200_OK,
                    )

                def delete(self, req, pk):
                    a = self.go(pk)
                    a.delete()
                    return Response(
                        status=HTTP_204_NO_CONTENT,
                    )

                def put(self, req, pk):
                    a = self.go(pk)
                    ser = AmenitySerializer(
                        a,
                        data=req.data,
                        partial=True,
                    )
                    if ser.is_valid():
                        ua = ser.save()
                        return Response(
                            AmenitySerializer(ua).data,
                            status=HTTP_202_ACCEPTED,
                        )
                    else:
                        return Response(
                            status=HTTP_400_BAD_REQUEST,
                        )


        rooms > urls >
            from . import views
            from django.urls import path

            urlpatterns = [
                path("amenities/", views.Amenities.as_view()),
                path("amenities/<int:pk>/", views.AmenityDetail.as_view()),
            ]



        rooms/serializers >
            from rest_framework.serializers import ModelSerializer
            from .models import Amenity


            class AmenitySerializer(ModelSerializer):
                class Meta:
                    model = Amenity
                    fields = "__all__"


    2. Perks & PerkDetail
        
        above rinse/repeat

    3. Rooms

        above rinse/repeat

        Expand foreignkeys
        NOTRECOMMENDED
        serializer > RS > Meta
            depth = 1
        

    4. RoomDetail

        keep database from overfetching (get all):

        room/serializer >

            class RoomListSerializer(ModelSerializer):
                class Meta:
                    model = Room
                    fields = ["pk", "name", "country", "city", "price",]


            class RoomDetailSerializer(ModelSerializer):

                owner = TinyUserSerializer()
                amenities = AmenitySerializer(many=True)
                category = CategorySerializer()

                class Meta:
                    model = Room
                    fields = "__all__"



        users/serializer >
            from rest_framework.serializers import ModelSerializer
            from .models import User


            class TinyUserSerializer(ModelSerializer):
                class Meta:
                    model = User
                    fields = [
                        "id",
                        "username",
                    ]


    5. Create Room

        to prevent users from modifying the request to alter another
        user's account, we make owner read only


        class RoomDetailSerializer(ModelSerializer):

            owner = TinyUserSerializer(read_only=True)
            amenities = AmenitySerializer(many=True)
            category = CategorySerializer()

            class Meta:
                model = Room
                fields = "__all__"


    6. Room owner

        views
        class Rooms(APIView):
            def get(self, req):
                all = Room.objects.all()
                ser = RoomListSerializer(
                    all,
                    many=True,
                )
                return Response(
                    ser.data,
                    status=HTTP_200_OK,
                )

            def post(self, req):
                if req.user.is_authenticated:
                    ser = RoomDetailSerializer(
                        data=req.data,
                    )
                    if ser.is_valid():
                        new = ser.save(owner=req.user)
                        ser = RoomListSerializer(new)
                        return Response(
                            ser.data,
                            status=HTTP_201_CREATED,
                        )
                    else:
                        return Response(
                            ser.errors,
                            status=HTTP_400_BAD_REQUEST,
                        )
                else:
                    raise NotAuthenticated

        serializers
        class RoomDetailSerializer(ModelSerializer):

            owner = TinyUserSerializer(read_only=True)
            amenities = AmenitySerializer(read_only=True, many=True)
            category = CategorySerializer(read_only=True)

            class Meta:
                model = Room
                fields = "__all__"


    7. Room Category

        FOR TESTING
        def create(self, validated_data):
            print(validated_data)
            return
        END FOR TESTING

        def post(self, req):
            if req.user.is_authenticated:
                ser = RoomDetailSerializer(
                    data=req.data,
                )
                if ser.is_valid():
                    category_pk = req.data.get("category")
                    if not category_pk:
                        raise ParseError
                    try:
                        category = Category.objects.get(pk=category_pk)
                        if category.kind == Category.CategoryKindChoices.EXPERIENCES:
                            raise ParseError
                    except Category.DoesNotExist:
                        raise ParseError
                    new_room = ser.save(owner=req.user)
                    ser = RoomListSerializer(new_room)
                    return Response(
                        ser.data,
                        status=HTTP_201_CREATED,
                    )
                else:
                    return Response(
                        ser.errors,
                        status=HTTP_400_BAD_REQUEST,
                    )
            else:
                raise NotAuthenticated

    8. Room Amenities

        def post(self, req):
            if req.user.is_authenticated:
                ser = RoomDetailSerializer(
                    data=req.data,
                )
                if ser.is_valid():
                    category_pk = req.data.get("category")
                    if not category_pk:
                        raise ParseError("Category is required")
                    try:
                        category = Category.objects.get(pk=category_pk)
                        if category.kind == Category.CategoryKindChoices.EXPERIENCES:
                            raise ParseError("Category kind should be rooms")
                    except Category.DoesNotExist:
                        raise ParseError("Category not found!")
                    new_room = ser.save(owner=req.user, category=category)
                    amenities = req.data.get("amenities")
                    for ame_pk in amenities:
                        try:
                            amenity = Amenity.objects.get(pk=ame_pk)
                        except Amenity.DoesNotExist:
                            new_room.delete()
                            raise ParseError(f"Amenity with ID {ame_pk} Does not Exist")
                        new_room.amenities.add(amenity)
                    ser = RoomListSerializer(new_room)
                    return Response(
                        ser.data,
                        status=HTTP_201_CREATED,
                    )
                else:
                    return Response(
                        ser.errors,
                        status=HTTP_400_BAD_REQUEST,
                    )
            else:
                raise NotAuthenticated


    9. Transactions

        All to succeed or none to succeed
        all or nothing bby
        Way of rolling back

        from django,db import transactions

        with transactions.atomic():
            CODE HERE

        views >
            def post(self, req):
                if req.user.is_authenticated:
                    ser = RoomDetailSerializer(
                        data=req.data,
                    )
                    if ser.is_valid():
                        category_pk = req.data.get("category")
                        if not category_pk:
                            raise ParseError("Category is required")
                        try:
                            category = Category.objects.get(pk=category_pk)
                            if category.kind == Category.CategoryKindChoices.EXPERIENCES:
                                raise ParseError("Category kind should be rooms")
                        except Category.DoesNotExist:
                            raise ParseError("Category not found!")
                        try:
                            with transaction.atomic():
                                new_room = ser.save(
                                    owner=req.user,
                                    category=category,
                                )
                                amenities = req.data.get("amenities")
                                for ame_pk in amenities:
                                    amenity = Amenity.objects.get(pk=ame_pk)
                                    new_room.amenities.add(amenity)
                                ser = RoomListSerializer(new_room)
                                return Response(
                                    ser.data,
                                    status=HTTP_201_CREATED,
                                )
                        except Exception:
                            raise ParseError("Amenity not found")

                    else:
                        return Response(
                            ser.errors,
                            status=HTTP_400_BAD_REQUEST,
                        )
                else:
                    raise NotAuthenticated

    10. Delete Rooms


        views >
        class RoomDetail(APIView):
            def go(self, pk):
                try:
                    obj = Room.objects.get(pk=pk)
                except Room.DoesNotExist:
                    raise NotFound
                return obj

            def get(self, req, pk):
                obj = self.go(pk)
                ser = RoomDetailSerializer(obj)
                return Response(
                    ser.data,
                    status=HTTP_200_OK,
                )

            def delete(self, req, pk):
                room = self.go(pk)
                if not req.user.is_authenticated:
                    raise NotAuthenticated
                if room.owner != req.user:
                    raise PermissionDenied
                room.delete()
                return Response(
                    status=HTTP_204_NO_CONTENT,
                )

            def put(self, req, pk):
                room = self.go(pk)
                if not req.user.is_authenticated:
                    raise NotAuthenticated
                if room.owner != req.user:
                    raise PermissionDenied
                ser = RoomDetailSerializer(
                    room,
                    data=req.data,
                    partial=True,
                )
                if ser.is_valid():
                    upd = ser.save()
                    return Response(
                        RoomDetailSerializer(upd).data,
                        status=HTTP_202_ACCEPTED,
                    )
                else:
                    return Response(
                        ser.errors,
                        status=HTTP_400_BAD_REQUEST,
                    )


    11. SerializerMethodField

        class RoomDetailSerializer(ModelSerializer):

            owner = TinyUserSerializer(read_only=True)
            amenities = AmenitySerializer(read_only=True, many=True)
            category = CategorySerializer(read_only=True)

            rating = serializers.SerializerMethodField()

            class Meta:
                model = Room
                fields = "__all__"

            def get_rating(self, room):
                return room.rating()


    12. Serializer Context

        def get(self, req, pk):
            obj = self.go(pk)
            ser = RoomDetailSerializer(
                obj,
                context={"request": req},
            )
            return Response(
                ser.data,
                status=HTTP_200_OK,
            )


        class RoomListSerializer(ModelSerializer):

            rating = serializers.SerializerMethodField()
            is_owner = serializers.SerializerMethodField()

            class Meta:
                model = Room
                fields = [
                    "pk",
                    "name",
                    "country",
                    "city",
                    "price",
                    "rating",
                    "is_owner",
                ]

            def get_is_owner(self, room):
                req = self.context["request"]
                return room.owner == req.user

            def get_rating(self, room):
                return room.rating()

    13. Reverse serializers

        NOT RECOMMENDED

        example: find reviews for a room:

            room.reviews.all() -- related_name


        reviews > serializers
            from rest_framework import serializers
            from .models import Review


            class ReviewSerializer(serializers.ModelSerializer):
                class Meta:
                    model = Review
                    fields = "__all__"


        rooms > RoomDetailSerializer
            reviews = ReviewSerializer(many=True, read_only=True)

        NOT RECOMMENDED AS ONE ROOM CAN HAVE MILLIONS OF REVIEWS
        PAGINATION IS RECOMMENDED


    14. Pagination



        rooms / urls >
            path("<int:pk>/reviews", views.RoomReviews.as_view()),

        TESTING IN GET VIEWS
        page = req.query_params.get('page', 1)
        page = int(page)
        <int:pk>/reviews?page=2


        rooms / views >
            class RoomReviews(APIView):
                def go(self, pk):
                    try:
                        obj = Room.objects.get(pk=pk)
                    except Room.DoesNotExist:
                        raise NotFound
                    return obj

                    def get(self, req, pk):
                        try:
                            page = req.query_params.get('page', 1)
                            page = int(page)
                        except ValueError:
                            # If user sends asdbaishdgba as page
                            page = 1
                        page_size=10
                        start = (page-1) * page_size
                        end = start + page_size
                        room = self.go(pk)
                        ser = ReviewSerializer(
                            room.reviews.all()[start:end],
                            many=True,
                        )
                        return Response(
                            ser.data,
                            status=HTTP_200_OK,
                        )

        CREATED ROOMS / 1 / AMENITIES

        room/serializer/RoomDetailSerializer >
            # amenities = AmenitySerializer(read_only=True, many=True)


        rooms/urls >
            path("<int:pk>/amenities", views.RoomAmenities.as_view()),

        rooms/views >
            class RoomAmenities(APIView):
                def go(self, pk):
                    try:
                        obj = Room.objects.get(pk=pk)
                    except Room.DoesNotExist:
                        raise NotFound
                    return obj

                def get(self, req, pk):
                    try:
                        page = req.query_params.get("page", 1)
                        page = int(page)
                    except ValueError:
                        # If user sends asdbaishdgba as page
                        page = 1
                    page_size = 10
                    start = (page - 1) * page_size
                    end = start + page_size
                    room = self.go(pk)
                    ser = AmenitySerializer(
                        room.amenities.all()[start:end],
                        many=True,
                    )
                    return Response(
                        ser.data,
                        status=HTTP_200_OK,
                    )


    15. File Uploads
        rooms/urls >
            path("<int:pk>/photos", views.RoomPhotos.as_view()),

        rooms/views >
            class RoomPhotos(APIView):
                def post(self, req, pk):
                    pass

        config > settings > 
            MEDIA_ROOT = "uploads"
            MEDIA_URL = "user-uploads/"

        config > urls >
            from django.conf.urls.static import static
            from django.conf import settings

            urlpatterns = [
                path("admin/", admin.site.urls),
                path("graphql", GraphQLView.as_view(schema=schema)),
                path("api/v1/rooms/", include("rooms.urls")),
                path("api/v1/categories/", include("categories.urls")),
                path("api/v1/experiences/", include("experiences.urls")),
            ] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)


        rooms/views >
            from django.conf import settings
            page_size = settings.PAGE_SIZE


        http://localhost:8000/user-uploads/5b2ec3d72d2404f4700774c1db9203d8.png

        NOT RECOMMENDED FOR PRODUCTION DUE TO SECURITY CONCERNS
        UPLOADING IMAGES/CODE NEXT TO YOUR CODE

    16. Upload photo

        WILL PUT UPLOADS ON ANOTHER SERVER (CF SERVER)

        change from file to urls field
        medias/models >
        class Photo(CommonModel):
            """Def for Photos"""

            file = models.URLField()

        class Video(CommonModel):
            """Def for Videos"""

            file = models.URLField()

        kill & makemigrations && migrate

        medias > serializers.py >
            from rest_framework.serializers import ModelSerializer
            from .models import Photo


            class PhotoSerializer(ModelSerializer):
                class Meta:
                    model = Photo
                    fields = [
                        "pk",
                        "file",
                        "description",
                    ]

        rooms > views >
            from medias.serializers import PhotoSerializer

            class RoomPhotos(APIView):
            # {
            # "file":"http://localhost:8000/api/v1/rooms/2/photos",
            # "description":"yoo"
            # }

            def go(self, pk):
                try:
                    room = Room.objects.get(pk=pk)
                except Room.DoesNotExist:
                    raise NotFound
                return room

            def post(self, req, pk):
                room = self.go(pk)
                if not req.user.is_authenticated:
                    raise NotAuthenticated
                if req.user != room.owner:
                    raise PermissionDenied


                ser = PhotoSerializer(
                    data=req.data,
                )
                if ser.is_valid():
                    photo = ser.save(room=room)
                    ser = PhotoSerializer(photo)
                    return Response(
                        ser.data,
                        status=HTTP_201_CREATED,
                    )
                else:
                    return Response(
                        ser.errors,
                        status=HTTP_400_BAD_REQUEST,
                    )

        ENSURE LOGGED IN TO AVOID 403 anonymous user

    17. permission_classes

        conf / urls.py >
            path("api/v1/medias", include("medias.urls")),

        
        media / urls.py >
            from django.urls import path
            from . import views

            urlpatterns = [
                path("/photos/<int:pk>", views.PhotoDetail.as_view()),
            ]

        medias / views >
            from rest_framework.views import APIView
            from .models import Photo
            from rest_framework.exceptions import NotFound

            class PhotoDetail(APIView):
                def go(self, pk):
                    try:
                        return Photo.objects.get(pk=pk)
                    except Photo.DoesNotExist:
                        raise NotFound

                def delete(self, req, pk):
                    photo = self.go(pk)
                    
        FOR DELETE, USER SHOULD BE AUTHED 
        TO AVOID REPETITIVELY TYPING OUT STUFF LIKE BELOW IN EACH METHOD:
            if (photo.room and photo.room.owner != req.user) or (
                photo.experience and photo.experience.host != req.user
            ):
                raise PermissionDenied

        WE USE PERMISSION CLASSES FROM DRF:
            ...
            from rest_framework.permissions import IsAuthenticated

            class PhotoDetail(APIView):
                permission_classes = [IsAuthenticated]
                ...
        
        THIS PROTECTS THE ENTIRE VIEW.
        TO PROTECT SPECIFIC METHODS (post, delete but not get) - AS WITH ROOMS
            from rest_framework.permissions import IsAuthenticatedOrReadOnly

            class RoomDetail(APIView):

                permission_classes = [IsAuthenticatedOrReadOnly]

                def go(self, pk):
                    try:
                        obj = Room.objects.get(pk=pk)
                    except Room.DoesNotExist:
                        raise NotFound
                    return obj

                def get(self, req, pk):
                    obj = self.go(pk)
                    ser = RoomDetailSerializer(
                        obj,
                        context={"request": req},
                    )
                    return Response(
                        ser.data,
                        status=HTTP_200_OK,
                    )

                def delete(self, req, pk):
                    room = self.go(pk)
                    if room.owner != req.user:
                        raise PermissionDenied
                    room.delete()
                    return Response(
                        status=HTTP_204_NO_CONTENT,
                    )

                def put(self, req, pk):
                    room = self.go(pk)
                    if room.owner != req.user:
                        raise PermissionDenied
                    ser = RoomDetailSerializer(
                        room,
                        data=req.data,
                        partial=True,
                    )
                    if ser.is_valid():
                        upd = ser.save()
                        return Response(
                            RoomDetailSerializer(upd).data,
                            status=HTTP_202_ACCEPTED,
                        )
                    else:
                        return Response(
                            ser.errors,
                            status=HTTP_400_BAD_REQUEST,
                        )

    18. Reviews 

        rooms > serializers
            from medias.serializers import PhotoSerializer

            class RoomDetailSerializer(ModelSerializer):

                owner = TinyUserSerializer(read_only=True)
                # amenities = AmenitySerializer(read_only=True, many=True)
                category = CategorySerializer(read_only=True)

                rating = serializers.SerializerMethodField()
                is_owner = serializers.SerializerMethodField()
                # reviews = ReviewSerializer(many=True, read_only=True)
                photos = PhotoSerializer(many=True, read_only=True)

                class Meta:
                    model = Room
                    fields = "__all__"

                def get_rating(self, room):
                    return room.rating()

                def get_is_owner(self, room):
                    req = self.context["request"]
                    return room.owner == req.user

            class RoomListSerializer(ModelSerializer):

                rating = serializers.SerializerMethodField()
                is_owner = serializers.SerializerMethodField()

                class Meta:
                    model = Room
                    fields = [
                        "pk",
                        "name",
                        "country",
                        "city",
                        "price",
                        "rating",
                        "is_owner",
                        "photos",
                    ]

                def get_is_owner(self, room):
                    req = self.context["request"]
                    return room.owner == req.user

                def get_rating(self, room):
                    return room.rating()

        rooms/views >
            class RoomReviews(APIView):

                permission_classes = [IsAuthenticatedOrReadOnly]

                def go(self, pk):
                    try:
                        obj = Room.objects.get(pk=pk)
                    except Room.DoesNotExist:
                        raise NotFound
                    return obj

                def get(self, req, pk):
                    try:
                        page = req.query_params.get("page", 1)
                        page = int(page)
                    except ValueError:
                        # If user sends asdbaishdgba as page
                        page = 1
                    page_size = settings.PAGE_SIZE
                    start = (page - 1) * page_size
                    end = start + page_size
                    room = self.go(pk)
                    ser = ReviewSerializer(
                        room.reviews.all()[start:end],
                        many=True,
                    )
                    return Response(
                        ser.data,
                        status=HTTP_200_OK,
                    )

                def post(self, req, pk):
                    ser = ReviewSerializer(data=req.data)
                    if ser.is_valid():
                        review = ser.save(
                            user=req.user,
                            room=self.go(pk),
                        )
                        ser = ReviewSerializer(review)
                        return Response(
                            ser.data,
                            status=HTTP_201_CREATED,
                        )
                    else:
                        return Response(
                            ser.errors,
                            status=HTTP_400_BAD_REQUEST,
                        )

    19. Wishlists

        config > urls >
            path("api/v1/wishlists", include("wishlists.urls")),

        wishlists > urls >
            from django.urls import path
            from . import views

            urlpatterns = [
                path("", views.Wishlists.as_view()),
            ]


        wishlists > serializers >
            from rest_framework.serializers import ModelSerializer
            from .models import Wishlist
            from rooms.serializers import RoomListSerializer


            class WishlistSerializer(ModelSerializer):
                rooms = RoomListSerializer(many=True, read_only=True)

                class Meta:
                    model = Wishlist
                    fields = [
                        "name",
                        "rooms",
                    ]



        wishlists > views >
            from rest_framework.views import APIView
            from rest_framework.response import Response
            from rest_framework.permissions import IsAuthenticatedOrReadOnly
            from rest_framework.status import HTTP_200_OK, HTTP_400_BAD_REQUEST, HTTP_201_CREATED
            from .models import Wishlist
            from .serializers import WishlistSerializer


            class Wishlists(APIView):
                permission_classes = [IsAuthenticatedOrReadOnly]

                def get(self, req):
                    all_wishlists = Wishlist.objects.filter(user=req.user)
                    ser = WishlistSerializer(
                        all_wishlists,
                        many=True,
                        context={"request": req},
                    )
                    return Response(ser.data, status=HTTP_200_OK)

                def post(self, req):
                    ser = WishlistSerializer(data=req.data)
                    if ser.is_valid():
                        wl = ser.save(
                            user=req.user,
                        )
                        ser = WishlistSerializer(wl)
                        return Response(
                            ser.data,
                            status=HTTP_201_CREATED,
                        )
                    else:
                        return Response(
                            ser.errors,
                            status=HTTP_400_BAD_REQUEST,
                        )

    20. Wishlist

        wl/urls >
            from django.urls import path
            from . import views

            urlpatterns = [
                path("", views.Wishlists.as_view()),
                path("<int:pk>", views.WishlistDetail.as_view()),
                path("<int:pk>/rooms/<int:room_pk>", views.WishlistToggle.as_view()),
            ]

        wl/serializers >
            class Meta:
            model = Wishlist
            fields = [
                "pk",
                "name",
                "rooms",
            ]

        wl/views >
        
            class WishlistDetail(APIView):

                permission_classes = [IsAuthenticated]

                def go(self, pk, user):
                    try:
                        return Wishlist.objects.get(pk=pk, user=user)
                    except Wishlist.DoesNotExist:
                        raise NotFound

                def get(self, req, pk):
                    wl = self.go(pk, req.user)
                    print(f"\n\n{wl}\n\n")
                    ser = WishlistSerializer(
                        wl,
                        context={"request": req},
                    )
                    print(f"\n\n{ser}\n\n")

                    print(f"\n\n{req.user}\n\n")
                    return Response(
                        ser.data,
                        status=HTTP_200_OK,
                    )

                def delete(self, req, pk):
                    wl = self.go(pk, user=req.user)
                    wl.delete()
                    return Response(status=HTTP_204_NO_CONTENT)

                def put(self, req, pk):
                    wl = self.go(pk=pk, user=req.user)
                    ser = WishlistSerializer(
                        wl,
                        data=req.data,
                        partial=True,
                    )
                    if ser.is_valid():
                        wl = ser.save()
                        ser = WishlistSerializer(
                            wl,
                        )
                        return Response(
                            ser.data,
                            status=HTTP_202_ACCEPTED,
                        )
                    else:
                        return Response(
                            ser.errors,
                            status=HTTP_400_BAD_REQUEST,
                        )


            class WishlistToggle(APIView):

                permission_classes = [IsAuthenticated]

                def go(self, pk, user):
                    try:
                        return Wishlist.objects.get(pk=pk, user=user)
                    except Wishlist.DoesNotExist:
                        raise NotFound

                def get_room(self, pk):
                    try:
                        return Room.objects.get(pk=pk)
                    except Room.DoesNotExist:
                        raise NotFound

                def put(self, req, pk, room_pk):
                    list = self.go(pk, req.user)
                    room = self.get_room(room_pk)

                    if list.rooms.filter(pk=room.pk).exists():
                        list.rooms.remove(room)
                    else:
                        list.rooms.add(room)

                    return Response(status=HTTP_202_ACCEPTED)

    21. is_liked

        rooms/ser>RoomDetailSerializer>

            is_liked = serializers.SerializerMethodField()

            def get_is_liked(self, room):
                req = self.context["request"]
                return Wishlist.objects.filter(user=req.user, rooms__id=room.pk).exists()

    22. Bookings

        IMPORT ORDER
            import all from django
            import all thirdparties (rf)
            import locals (.models)
            import others (rooms.models)


        rooms / urls >
            path("<int:pk>/bookings", views.RoomBookings.as_view()),


        bookings.serializers >
            from rest_framework import serializers

            from .models import Booking


            class PublicBookingSerializer(serializers.ModelSerializer):
                class Meta:
                    model = Booking
                    fields = [
                        "pk",
                        "check_in",
                        "check_out",
                        "experience_time",
                        "guests",
                    ]

        rooms.views >
            class RoomBookings(APIView):
                permission_classes = [IsAuthenticatedOrReadOnly]

                def go(self, pk):
                    try:
                        return Room.objects.get(pk=pk)
                    except Room.DoesNotExist:
                        raise NotFound

                def get(self, req, pk):
                    room = self.go(pk)
                    now = timezone.localtime(timezone.now()).date()
                    bookings = Booking.objects.filter(
                        room=room,
                        kind=Booking.BookingKindChoices.ROOM,
                        check_in__gt=now,
                    )
                    ser = PublicBookingSerializer(
                        bookings,
                        many=True,
                        context={"request": req},
                    )
                    return Response(
                        ser.data,
                        status=HTTP_200_OK,
                    )


    23. Create a Booking

        ser >
            class CreateRoomBookingSerializer(serializers.ModelSerializer):

            check_in = serializers.DateField()
            check_out = serializers.DateField()

            class Meta:
                model = Booking
                fields = [
                    "guests",
                    "check_in",
                    "check_out",
                ]

            def validate_check_in(self, value):
                now = timezone.localtime(timezone.now()).date()
                if now > value:
                    raise serializers.ValidationError("Booking must be a future date!")
                else:
                    return value

            def validate_check_out(self, value):
                now = timezone.localtime(timezone.now()).date()
                if now > value:
                    raise serializers.ValidationError("Booking must be a future date!")
                else:
                    return value

    24. Validate Booking

        ...ABOVE CODE

        def validate(self, data):
            if data["check_out"] <= data["check_in"]:
                raise serializers.ValidationError(
                    "Check In date should be before Check Out data"
                )

            if Booking.objects.filter(
                check_in__lte=data["check_out"], check_out__gte=data["check_in"]
            ).exists():
                raise serializers.ValidationError(
                    "A booking already exists between or on those dates"
                )
            return data


    25. Booking Completed

        rooms.views >
        def post(self, req, pk):
            room = self.go(pk)
            ser = CreateRoomBookingSerializer(data=req.data)
            if ser.is_valid():
                booking = ser.save(
                    room=room,
                    user=req.user,
                    kind=Booking.BookingKindChoices.ROOM,
                )
                ser = PublicBookingSerializer(booking)
                return Response(
                    ser.data,
                )
            else:
                return Response(
                    ser.errors,
                )



-------------------------------------------------------------------------

12. USERS API

    1. User Profile

        conf.urls >
            path("api/v1/users/", include("users.urls")),

        user.urls >
            from django.urls import path
            from . import views

            urlpatterns = [
                path("me", views.Me.as_view()),
            ]

        models >
            profile_photo = models.URLField(blank=True)
        MIGRATE

        models.serializers >

            class PrivateUserSerializer(ModelSerializer):
                class Meta:
                    model = User
                    exclude = [
                        "password",
                        "is_superuser",
                        "id",
                        "is_staff",
                        "is_active",
                        "first_name",
                        "last_name",
                        "groups",
                        "user_permissions",
                    ]

        users.views >
            class Me(APIView):
                permission_classes = [IsAuthenticated]

                def get(self, req):
                    user = req.user
                    return Response(
                        user_ser.PrivateUserSerializer(user).data,
                        status=status.HTTP_200_OK,
                    )

                def put(self, req):
                    user = req.user
                    ser = user_ser.PrivateUserSerializer(
                        user,
                        data=req.data,
                        partial=True,
                    )
                    if ser.is_valid():
                        user = ser.save()
                        ser = user_ser.PrivateUserSerializer(user)
                        return Response(
                            ser.data,
                            status=status.HTTP_202_ACCEPTED,
                        )
                    else:
                        return Response(
                            ser.errors,
                            status=status.HTTP_400_BAD_REQUEST,
                        )


    2. Create a User

        views >
            class Users(APIView):
                def post(self, req):
                    password = req.data.get("password")
                    if not password:
                        raise ParseError
                    ser = user_ser.PrivateUserSerializer(data=req.data)
                    if ser.is_valid():
                        user = ser.save()
                        user.set_password(password)
                        user.save()
                        ser = user_ser.PrivateUserSerializer(user)
                        return Response(
                            ser.data,
                            status=status.HTTP_201_CREATED,
                        )
                    else:
                        return Response(
                            ser.errors,
                            status=status.HTTP_400_BAD_REQUEST,
                        )


    3. Change password

        urls >
            urlpatterns = [
                path("", views.Users.as_view()),
                path("me", views.Me.as_view()),
                path("change-password", views.ChangePassword.as_view()),
                path("@<str:username>", views.PublicUser.as_view()),
            ]

        views >
            class ChangePassword(APIView):
                permission_classes = [IsAuthenticated]

                def put(self, req):
                    user = req.user
                    old_pass = req.data.get("old_password")
                    new_pass = req.data.get("new_password")
                    if not old_pass or not new_pass:
                        raise ParseError
                    if user.check_password(old_pass):
                        user.set_password(new_pass)
                        user.save()
                        return Response(status=status.HTTP_200_OK)
                    else:
                        raise ParseError


    4. Login and Logout

        urls >
            urlpatterns = [
                path("", views.Users.as_view()),
                path("me", views.Me.as_view()),
                path("change-password", views.ChangePassword.as_view()),
                path("log-in", views.Login.as_view()),
                path("log-out", views.Logout.as_view()),
                path("@<str:username>", views.PublicUser.as_view()),
            ]


        views >
            from django.contrib.auth import authenticate, login, logout
            
            class Login(APIView):
                def post(self, req):
                    username = req.data.get("username")
                    password = req.data.get("password")
                    if not username or not password:
                        raise ParseError
                    user = authenticate(
                        req,
                        username=username,
                        password=password,
                    )
                    if user:
                        login(req, user)
                        return Response({"ok": "welcome"})
                    else:
                        return Response({"error": "wrong password"})


            class Logout(APIView):
                permission_classes = [IsAuthenticated]

                def post(self, req):
                    logout(req)
                    return Response({"ok": "Bye"})


-------------------------------------------------------------------------

13. CHECKPOINT

    Code Challenge: 
        Build Experiences API

        GET POST /experiences
        GET PUT DELETE /experiences/1
        GET /experiences/1/Perks
        GET POST /perks [x]
        GET PUT DELETE /perks/1 [x]
        GET POST /experiences/1/bookings
        GET PUT DELETE /experiences/1/bookings/2

-------------------------------------------------------------------------

14. GRAPHQL API
    
    WILL NOT USE BUT SEE BOTTOM FOR GRAPHQL 

-------------------------------------------------------------------------

15. AUTHENTICATION

    0. Intro

    1. Customn Authentication 

    2. Recap 

    3. Token Authentication 

    4. JWT Encode

    5. JWT Decode

    6. Environment Files

-------------------------------------------------------------------------

16. API TESTING


    0. Intro

    1. Our First Test 

    2. Amentities Test

    3. Create Amenitiy Test

    4. Amenity Detail Test

    5. Test Authentication


-------------------------------------------------------------------------
-------------------------------------------------------------------------

17. FRONT-END SETUP

    0. Introduction

    1. Requirements

    2. Setup

    3. Router Setup

    4. Not Found page

    5. Chakra Tour


-------------------------------------------------------------------------

18. CHAKRA UI


    1. Header

    2. Login Modal

    3. Signup Modal

    4. Dark Mode

    5. Rooms Grid

    6. Responsive Design

    7. Skeletons


-------------------------------------------------------------------------

19. REACT QUERY / TANSTACK QUERY


    1. Manual Fetching
    
    2. Recap

    3. React Query / Tanstack

    4. Axios

    5. Room Detail

    6. Devtools and Query Keys

    7. Photos Grid

    8. Reviews

    9. Conclusion

-------------------------------------------------------------------------

20. AUTHENTICATION (FRONTEND)

    1. useUser


    2. Credentials



        2b RECAP

    3. Log Out


    4. CSRF


    5. Github Login


    6. Github Code


    7. Access Token


    8. Emails


    9. Kakao Talk App


    10. Kakao Talk Auth


    11. Kakao Login


    12. Login Form


    13. React Hook Form


    14. useMutation


    15. Recap & Code Challenge 

-------------------------------------------------------------------------

21. UPLOAD ROOM

    1. Protected Pages


    2. Upload Form


    3. Dynamic Form


    4. register


    5. Bugfix


    6. Upload Form


    7. One-Time Upload


    8. File Upload


    9. Final Mutation


    10. Recap

-------------------------------------------------------------------------

22. CALENDAR


    1. Calendar Component


    2. Booking Dates


    3. Checking Dates


    4. Timezones


    5. Code Challenge

-------------------------------------------------------------------------

23. DEPLOYMENT

    1. Render Blueprint


    2. Sentry


    3. Custom Domain


    4. Rewrites


    5. Conclusions

-------------------------------------------------------------------------






-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
14 GRAPHQL - UNNECESSARY

    poetry add strawberry-graphql[debug-server]
    poetry add strawberry-graphql-django
    THIRD_PARTY_APPS >
        "strawberry.django",

    1. Query

        DUMMY API
         
        python has typing
            name:str = "bob"
            def hello(person:str) -> str:
                return f"hello {person}"

        config > create schema.py
            import strawberry

            @strawberry.type
            class Query:
                @strawberry.field
                def ping(self) -> str:
                    return "pong"

            schema = strawberry.Schema(query=Query)
        
        urls.py >
            from strawberry.django.views import GraphQLView
            from .schema import schema

            path("graphql", GraphQLView.as_view(schema=schema)),


        navigate to localhost:8000/graphql

            {
                ping
            }

            res: 
                {
                    "data": {
                        "ping": "pong"
                    }
                }

    2. Query Arguments
        schema >
            import strawberry
            import typing


            @strawberry.type
            class Movie:
                pk: int
                title: str
                year: int
                rating: int


            movies_db = [Movie(pk=1, title="The Godfather", year=1990, rating=10)]


            @strawberry.type
            class Query:
                @strawberry.field
                def movies(self) -> typing.List[Movie]:
                    return movies_db

                @strawberry.field
                def movie(self, movie_pk: int) -> Movie:
                    return movies_db[movie_pk - 1]


            schema = strawberry.Schema(query=Query)


        gql >
            {
                movie(moviePk:1){
                    title
                    year
                    rating
                }
            }

    3. Mutation

        Add to bottom schema >
            @strawberry.type
            class Mutation:
                @strawberry.mutation
                def add_movie(self, title: str, year: int, rating: int) -> Movie:
                    new_movie = Movie(
                        pk=len(movies_db) + 1,
                        title=title,
                        year=year,
                        rating=rating,
                    )
                    movies_db.append(new_movie)
                    return new_movie


            schema = strawberry.Schema(query=Query, mutation=Mutation)


        gql >
            mutation {
                addMovie(title:"Godfather II", year: 2000, rating: 8) {
                    pk
                    title
                }
            }

    4. Refactor

        Move queries/mutations

        def movies():
            return movies_db


        def movie(movie_pk: int):
            return movies_db[movie_pk - 1]


        def add_movie(title: str, year: int, rating: int):
            new_movie = Movie(
                pk=len(movies_db) + 1,
                title=title,
                year=year,
                rating=rating,
            )
            movies_db.append(new_movie)
            return new_movie


        @strawberry.type
        class Query:
            movies: typing.List[Movie] = strawberry.field(resolver=movies)
            movie: Movie = strawberry.field(resolver=movie)


        @strawberry.type
        class Mutation:
            add_movie: Movie = strawberry.mutation(resolver=add_movie)


        schema = strawberry.Schema(query=Query, mutation=Mutation)

    5. Django Types
        GUT
        import strawberry

        @strawberry.type
        class Query:
            pass

        @strawberry.type
        class Mutation:
            pass

        schema = strawberry.Schema(query=Query, mutation=Mutation)

        rooms > types.py >
            import strawberry
            from strawberry import auto
            from . import models


            @strawberry.django.type(models.Room)
            class Room:
                id: auto
                name: auto
                kind: auto

        rooms > schema.py >
            import strawberry
            import typing
            from . import types
            from . import queries

            @strawberry.type
            class Query:
                all_rooms: typing.List[types.Room] = strawberry.field(
                    resolver=queries.get_all_rooms
                )

        rooms > queries.py >
            from . import models

            def get_all_rooms():
                return models.Room.objects.all()

        config > schema.py >
            import strawberry
            from rooms import schema as rooms_schema


            @strawberry.type
            class Query(rooms_schema.Query):
                pass


            # @strawberry.type
            # class Mutation:
            #     pass


            schema = strawberry.Schema(
                query=Query,
            )

        gql > 
            {
                allRooms {
                    id
                    name
                    kind
                }
            }


    6. Type Relationships

        users > types.py
            import strawberry
            from strawberry import auto
            from . import models

            @strawberry.django.type(models.User)
            class UserType:
                name: auto
                email: auto
                username: auto

        
        rooms > types.py 
            import strawberry
            from strawberry import auto
            from . import models
            from users.types import UserType

            @strawberry.django.type(models.Room)
            class Room:
                id: auto
                name: auto
                kind: auto
                owner: 'UserType'


        gql > 
            {
                allRooms {
                    id
                    name
                    kind
                    owner {
                        username
                    }
                }
            }



    7. Paginated Relationships

        reviews > types.py >
            import strawberry
            from strawberry import auto
            from . import models


            @strawberry.django.type(models.Review)
            class ReviewType:
                id: auto
                payload: auto
                rating: auto

        rooms > types >
            add
                import typing
                from reviews.types import ReviewType
                from django.conf import settings

             &
                @strawberry.field
                def reviews(self, page: int) -> typing.List["ReviewType"]:
                    page_size = settings.PAGE_SIZE
                    start = (page - 1) * page_size
                    end = start + page_size
                    return self.reviews.all()[start:end]

                @strawberry.field
                def rating(self) -> str:
                    return self.rating

                
        gql >
            {
                allRooms {
                    id
                    name
                    kind
                    owner {
                    username
                    }
                    reviews(page:1){
                        id
                        payload
                        rating
                    }
                }
            }


    8. Custom Resolvers

        gql >
            {
                allRooms {
                    name 
                    isOwner
                    isLiked
                }
            }


            {
                room(pk:1) {
                    name
                    rating
                    reviews(page:1) {
                        rating
                        payload
                    }
                }
            }


        rooms > queries
            from . import models


            def get_all_rooms():
                return models.Room.objects.all()


            def get_room(pk: int):
                try:
                    return models.Room.objects.get(pk)
                except models.Room.DoesNotExist:
                    return None

        rooms > schema
            import strawberry
            import typing
            from . import types
            from . import queries


            @strawberry.type
            class Query:
                all_rooms: typing.List[types.RoomType] = strawberry.field(
                    resolver=queries.get_all_rooms
                )
                room: typing.Optional[types.RoomType] = strawberry.field(resolver=queries.get_room)


        rooms types 

            import strawberry
            from strawberry import auto
            from strawberry.types import Info
            from . import models
            from users.types import UserType
            import typing
            from reviews.types import ReviewType
            from django.conf import settings
            from wishlists.models import Wishlist


            @strawberry.django.type(models.Room)
            class RoomType:
                id: auto
                name: auto
                kind: auto
                owner: "UserType"

                @strawberry.field
                def reviews(self, page: typing.Optional[int] = 1) -> typing.List["ReviewType"]:
                    page_size = settings.PAGE_SIZE
                    start = (page - 1) * page_size
                    end = start + page_size
                    return self.reviews.all()[start:end]

                @strawberry.field
                def rating(self) -> str:
                    return self.rating

                @strawberry.field
                def is_owner(self, info: Info) -> bool:
                    return self.owner == info.context.request.user

                @strawberry.field
                def is_liked(self, info: Info) -> bool:
                    return Wishlist.objects.filter(
                        user=info.context.request.user,
                        rooms__pk=self.pk,
                    ).exists()


    9. Permissions 

        NOPE
        rooms/queries >
            from strawberry.types import Info

            def get_all_rooms(info: Info):
                if info.context.request.user.is_authenticated:
                    return models.Room.objects.all()
                else:
                    raise Exception("Not Auth.")

        NOPE (as REPETITIVE) -> INSTEAD:

        rooms/schema >
            import strawberry
            from . import types
            from . import queries

            import typing
            from common.permissions import OnlyLoggedIn


            @strawberry.type
            class Query:
                all_rooms: typing.List[types.RoomType] = strawberry.field(
                    resolver=queries.get_all_rooms,
                    permission_classes=[
                        OnlyLoggedIn,
                    ],
                )
                room: typing.Optional[types.RoomType] = strawberry.field(resolver=queries.get_room)


        common/permissions >
            from strawberry.permission import BasePermission
            from strawberry.types import Info
            import typing


            class OnlyLoggedIn(BasePermission):

                message = "You need to be logged in for this"

                def has_permission(self, source: typing.Any, info: Info):
                    return info.context.request.user.is_authenticated

